#!/bin/bash
# Script to format and print a single diary entry. 

minimum_width=10
long_date_format="%A %d %B %Y %I:%M%p"
short_date_format="%A %d %B %I:%M%p"
very_short_date_format="%I:%M%p"
pad_char="-"
metadata_colour="\e[1;34m"  # Bold blue.
pad_colour="\e[0;34m"       # Blue.
end_colour="\e[0m"

function format_entry {
    # First do any text changing edits.
    do_edits | \
    # Then fold the text.
    fold -s -w "$width" | \
    # Then do highlighting. 
    do_highlight

    # Echo one more empty line at the end. 
    echo ""
}

function do_edits {
    while read line; do
        echo $line
    done
}

function do_highlight {
    while read line; do
        if [[ $search_string ]]; then
            grep --colour=always -i "\|$search_string" <<< "$line"
        else
            echo $line
        fi
    done
}

function print_metadata {
    # Argument must be in the format: diary-<TIMESTAMP>-<DEVICE>.txt
    entry="$1"
    entry=${entry##*diary-}
    timestamp=${entry%%-*}
    entry=${entry#*-}
    device=${entry%.*} # Device is not currently used. 

    # If there was an error in extracting the information then skip this.
    if [[ $timestamp && $device ]]; then 

        # Metadata string currently consists of just the date. 
        date_string=$(get_date_string $timestamp)
        metadata_string=" $date_string "

        # Make sure there is the right amount of padding on either side.
        start_padding=""
        end_padding=""
        if (( (width-${#metadata_string})%2==1 )); then 
            end_padding=$pad_char
        fi
        while (( ${#metadata_string} + ${#start_padding} + \
                 ${#end_padding} < $width )); do 
            start_padding=$start_padding$pad_char
            end_padding=$end_padding$pad_char
        done
        
        # Print it, with colours. 
        start_padding=$pad_colour$start_padding$end_colour
        end_padding=$pad_colour$end_padding$end_colour
        metadata_string=$metadata_colour$metadata_string$end_colour
        echo -e $start_padding$metadata_string$end_padding
    fi
}

function get_date_string {

    timestamp="$1"
    now=$(date +%s)

    #let time_diff=now-timestamp
    #let seconds=time_diff%60
    #let time_diff=time_diff/60
    #let minutes=time_diff%60
    #let time_diff=time_diff/60
    #let hours=time_diff%24
    #let time_diff=time_diff/24
    #let days=time_diff

    # Get date information
    read year day hour minute <<< \
        "$(date '+%Y %j %H %M' -d @$timestamp)"
    read this_year this_day this_hour this_minute <<< \
        "$(date '+%Y %j %H %M' -d @$now)"


    # Find yesterday's day number.
    yesterday=$(date +%j -d yesterday)

    # Remove leading zeros (extended globbing does not work here).
    yesterday=${yesterday#0}
    yesterday=${yesterday#0}
    this_day=${this_day#0}
    this_day=${this_day#0}
    this_hour=${this_hour#0}
    this_minute=${this_minute#0}
    day=${day#0}
    day=${day#0}
    hour=${hour#0}
    minute=${minute#0}


    # In the future
    if ((timestamp>now)); then 
        echo $(date "+$long_date_format" -d "@$timestamp") "(in the future)"
    
    # Today
    elif ((this_year==year && this_day==day)); then 
        echo Today $(date "+$very_short_date_format" -d "@$timestamp")
    
    # Yesterday
    elif (( (this_year==year && this_day-day==1) || \
            (this_year-year==1 && yesterday==day) )); then
        echo Yesterday $(date "+$very_short_date_format" -d "@$timestamp")

    # Over two days ago, still this year
    elif ((this_year==year)); then 
        date "+$short_date_format" -d "@$timestamp"

    # Over two days ago, not this year
    else
        date "+$long_date_format" -d "@$timestamp"

    fi

}


function usage_and_exit {
    echo "Help not implemented yet."
    exit 1
}

function check_width {
    [ "$1" -ge $minimum_width ] 2>/dev/null || usage_and_exit
}

# Set default width.
width=$(tput cols)

# Process command line args.
while true; do
    case $1 in 
        -w ) 
            shift
            width="$1"
            shift
            check_width "$width"
        ;;
        --width=* ) 
            width=${1#--width=}
            shift
            check_width "$width"
        ;;
        -m | --metadata )
            metadata=true
            shift
        ;;
        -s )
            shift
            search_string="$1"
            shift
        ;;
        --search=* ) 
            search_string=${1#--search=}
            shift
        ;;
        * ) 
            break
        ;;
    esac
done


# Single argument is a filename or '-' or empty for stdin. 
if [[ $# == 0 || "$1" == "-" ]]; then 
    format_entry
else
    [[ $metadata ]] && print_metadata "$1"
    format_entry < "$1"
fi
