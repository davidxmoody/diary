#!/bin/bash
# Script to format and print a single diary entry. 

format_entry() {
    # First do any text changing edits.
    #do_edits | \
    # Then fold the text.
    fold -s -w "$width" | \
    # Then do highlighting. 
    do_highlight

    # Echo one more empty line at the end. 
    echo ""
}

do_edits() {
    cat
}

do_highlight() {
    if [[ "$search_string" ]]; then
        grep --colour=always -i "\|$search_string"
    else 
        cat
    fi
}

print_metadata() {
    # Argument must be in the format: diary-<TIMESTAMP>-<DEVICE>.txt
    entry="$1"
    entry=${entry##*diary-}
    timestamp=${entry%%-*}
    entry=${entry#*-}
    device=${entry%.*}

    # Get wordcount data.
    wordcount_data=$(diary-wordcount -s "$1")


    # Only continue if information was extracted properly.
    if [[ $timestamp && $device ]]; then 

        # Metadata string currently consists of just the date. 
        date_string=$(get_date_string $timestamp)
        metadata_string=" $date_string "

        # Make sure there is the right amount of padding on either side.
        # Also insert aditional information into the padding.
        start_padding="$pad_char$wordcount_data words$pad_char"
        end_padding="$pad_char$timestamp$pad_char"

        # While complete metadata string is less than the width, add one more 
        # character of padding and try to make both sides as even as possible.
        while (( ${#metadata_string} + ${#start_padding} + \
                 ${#end_padding} < $width )); do 
            if (( ${#start_padding} < ${#end_padding} )); then
                start_padding=$start_padding$pad_char
            else
                end_padding=$pad_char$end_padding
            fi
        done
        
        # Print it, with colours. 
        start_padding=$pad_colour$start_padding$end_colour
        end_padding=$pad_colour$end_padding$end_colour
        metadata_string=$metadata_colour$metadata_string$end_colour
        echo -e $start_padding$metadata_string$end_padding

    else
        # There was an error in extracting information so print 
        # the filename instead.
        echo "$1"

    fi
}

get_date_string() {

    timestamp="$1"
    now=$(date +%s)

    # Get date information
    read year day hour minute <<< \
        "$(date '+%Y %j %H %M' -d @$timestamp)"
    read this_year this_day this_hour this_minute <<< \
        "$(date '+%Y %j %H %M' -d @$now)"


    # Find yesterday's day number.
    yesterday=$(date +%j -d yesterday)

    # Remove leading zeros (extended globbing does not work here).
    yesterday=${yesterday#0}
    yesterday=${yesterday#0}
    this_day=${this_day#0}
    this_day=${this_day#0}
    this_hour=${this_hour#0}
    this_minute=${this_minute#0}
    day=${day#0}
    day=${day#0}
    hour=${hour#0}
    minute=${minute#0}


    # In the future
    if ((timestamp>now)); then 
        echo $(date "+$long_date_format" -d "@$timestamp") "(in the future)"
    
    # Today
    elif ((this_year==year && this_day==day)); then 
        echo Today $(date "+$very_short_date_format" -d "@$timestamp")
    
    # Yesterday
    elif (( (this_year==year && this_day-day==1) || \
            (this_year-year==1 && yesterday==day) )); then
        echo Yesterday $(date "+$very_short_date_format" -d "@$timestamp")

    # Over two days ago, still this year
    elif ((this_year==year)); then 
        date "+$short_date_format" -d "@$timestamp"

    # Over two days ago, not this year
    else
        date "+$long_date_format" -d "@$timestamp"

    fi

}

check_width() {
    [ "$1" -ge $header_minimum_width ] 2>/dev/null || exit 1
}

# Set default width.
width=$(tput cols)

# Process command line args.
while true; do
    case $1 in 
        -w ) 
            width="$2"
            check_width "$width"
            shift; shift
        ;;
        --width=* ) 
            width=${1#--width=}
            check_width "$width"
            shift
        ;;
        -m | --metadata )
            metadata=true
            shift
        ;;
        -s )
            search_string="$2"
            shift; shift
        ;;
        --search=* ) 
            search_string=${1#--search=}
            shift
        ;;
        * ) 
            break
        ;;
    esac
done


# Single argument is a filename or '-' or empty for stdin. 
if [[ $# == 0 || "$1" == "-" ]]; then 
    format_entry
else
    [[ $metadata ]] && print_metadata "$1"
    format_entry < "$1"
fi
