#!/bin/bash
# Script for finding the filenames of diary entries.

new_entry() {
    # Determine file name.
    device_name="$(hostname)"
    timestamp="$(date +%s)"
    file_name="diary-$timestamp-$device_name.txt"

    # Determine file path.
    month=$(date '+%Y-%m')
    file_path="$dir_entries/$month/$file_name"

    # Create the month folder (if it does not already exist).
    mkdir -p "$dir_entries/$month"

    # Echo it.
    echo "$file_path"
}

# Method is not used.
extract_timestamp() {
    # Extract the timestamp from any correctly formatted diary entry filename.
    # Filename can be relative or absolute.
    timestamp="${1##*diary-}"
    timestamp="${timestamp%%-*}"
    echo "$timestamp"
}
    
get_entries() {
    # $1 is -r if reverse order is required empty otherwise, 
    # $2 is start index (inclusive) may be empty for no start,
    # $3 is end index (exclusive) may be empty for no end.
    reverse=$1
    entry_counter=0
    start_index=$2
    [[ -z "$start_index" ]] && start_index=0
    end_index=$3

    # If start_index or end_index are negative then return.
    # TODO make it so that I don't have to do this. 
    (( start_index < 0 )) && return
    (( end_index < 0 )) && return

    for month in $(ls -1 $reverse); do
        for entry in $(ls -1B $reverse "$month"); do

            # If the end of the desired entries has been reached, stop.
            [[ "$end_index" ]] && (( entry_counter >= end_index )) && return
            
            # Only consider entries past the start index. 
            if (( entry_counter >= start_index )); then
                echo "$dir_entries/$month/$entry"
            fi

            # Increment the entry counter. 
            let entry_counter++

        done
    done
}


# Process command line arguments.
range=
timestamp=
while true; do
    case "$1" in 
        -n | --new)
            shift
            new_entry "$@"
            exit
        ;;
        # TODO add options for referencing by fixed id, etc.
        # TODO add support for multiple ranges
        # TODO add support for reversing the order of entries
        -r)
            range="$2"
            shift; shift
        ;;
        --range=*)
            range="${1#--range=}"
            shift
        ;;
        -t)
            timestamp="$2"
            shift; shift
        ;;
        --timestamp=*)
            timestamp="${1#--timestamp=}"
            shift
        ;;
        *)
            break
        ;;
    esac
done

# cd to the entries directory.
cd "$dir_entries"

# Handle timestamp requests first.
# TODO move this to a separate method and enable ranges of dates.
if [[ "$timestamp" ]]; then
    month="$(date '+%Y-%m' -d @$timestamp)"
    for entry in $month/diary-$timestamp-*.txt; do
        if [[ -f "$entry" ]]; then
            echo "$dir_entries/$entry"
        fi
    done
    exit
fi


# Extract slice information.
if [[ "$range" =~ ^((\+|-|_)?[0-9]+)?:((\+|-|_)?[0-9]+)?$ ]]; then
    low=${range%%:*}
    high=${range##*:}
    stride=1

elif [[ "$range" =~ ^((\+|-|_)?[0-9]+)?:((\+|-|_)?[0-9]+)?:((\+|-|_)?[0-9]+)?$ ]]; then
    low=${range%%:*}
    stride=${range##*:}
    high=${range#*:}
    high=${high%:*}

else
    exit 1

fi

# Replace leading '_'s with '-'s.
low=${low/#_/-}
high=${high/#_/-}
stride=${stride/#_/-}


# +x:       (get_entries ""  x "")
# +x:+y     (get_entries ""  x  y)
# -x:  :-1  (get_entries -r  0 -x)
# -x:-y:-1  (get_entries -r -y -x)
case "$stride" in
    1|+1)
        get_entries "" "$low" "$high"
    ;;
    -1)
        [[ "$low" ]] && let 'low *= -1'
        [[ "$high" ]] && let 'high *= -1'
        get_entries -r "$high" "$low"
    ;;
esac
