#!/usr/bin/env python3

# Command line args:
# - Maybe specify only one tag to display.
# - Maybe change format of displayed text.
# - Enable/disable colour.
# - Add or remove tags to the list of monitored tags.
# - Rebuild cache.

# Algorithm for calculating chains:
# - Scan through all diary entries (or all entries modified since last scan).
# - For each one if it has any tag in it, write a log entry with the entry's .
#   timestamp and that tag (in the case of more than one tag in an entry, 
#   write multiple log entries).
# - Sort by timestamp (or assume it's already sorted).
# - Starting with the most recent timestamp, work backwards and make a note
#   every time a tag is encountered. Tag aliases or some form of regular 
#   expressions may be needed.
# - Every time a tag is encountered check to see if the last time that tag was
#   encountered was the previous day. If it was then increment the 
#   corresponding counter. If it wasn't then the corresponding counter is left
#   with the length of the longest chain (so stop considering that tag).

from subprocess import check_output
import os
import re
from datetime import datetime, timedelta
from time import localtime, mktime

tags_to_watch = { 'exercise'   : re.compile(r'exer.*'), 
                  'piano'      : re.compile(r'piano'), 
                  'meditation' : re.compile(r'medi.*'), 
                  'programming': re.compile(r'prog.*'), 
                  'writing'    : re.compile(r'writ.*|wrot.*'),
                  'driving'    : re.compile(r'driv.*|drov.*'),
                  'cooking'    : re.compile(r'cook.*'),
                  'remainder'  : re.compile(r'.*') }

tags_found = { tag_name: [] for tag_name in tags_to_watch.keys() }


def extract_timestamp(filename, timestamp_re=re.compile(r'.*diary-(\d+)-.*')):
    return timestamp_re.match(filename).group(1)

# Find out the path of the other diary scripts. 
real_path = os.environ['real_path']
diary_script = real_path + '/diary'

# Get a list of the filenames for all entries (in reverse order).
# TODO change back to full range
#all_entries = check_output(diary_script + ' range -r -60::-1', 
all_entries = check_output(diary_script + ' range -r ::-1', 
                           shell=True, universal_newlines=True)

# For each entry search for all tags.
for entry in all_entries.split('\n')[:-1]:
    command = r'grep -o "#\S\+\b" {} || true'.format(entry)
    matches = check_output(command, shell=True, universal_newlines=True)

    # Clean up output.
    for match in matches.split('\n'):
        match = match.lstrip('#').rstrip()
        if len(match)==0: continue

        # Find appropriate place to put timestamp of tag.
        for tag_name, tag_re in tags_to_watch.items():
            if tag_re.match(match):
                tags_found[tag_name].append(extract_timestamp(entry))


# Calculate whether or not the given struct_time objects occur on the same day.
def same_day(*dates):
    YD_pairs = [ (date.tm_year, date.tm_yday) for date in dates ]
    return YD_pairs.count(YD_pairs[0]) == len(YD_pairs)

# Return a string presenting the tag and chain length to the user (with color).
def format_details(tag, occurred_today, chain_length, *, no_color='\033[0m',
                   if_occurred='\033[1;32m', if_not_occurred='\033[1;31m'):
    color = if_occurred if occurred_today else if_not_occurred
    return '{:>12} {}{:>3}{}'.format(tag, color, chain_length, no_color)


# Calculate chain length from tags_found.
for tag, timestamps in tags_found.items():

    # The remainder tag is for anything not in the list of tags to watch.
    if tag == 'remainder': continue

    occurred_today = False
    chain_length = 0

    today = localtime()
    last_day = localtime()

    for timestamp in timestamps:
        day = localtime(float(timestamp))

        if same_day(day, today):
            occurred_today = True
        elif same_day(day, last_day):
            pass  # Do nothing because already counted this day once.
        else:
            last_day = localtime(mktime(last_day) - 24*60*60)
            if same_day(day, last_day):
                chain_length += 1
            else:
                break

    print(format_details(tag, occurred_today, chain_length))
