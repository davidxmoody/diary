#!/usr/bin/env python3
# Script for finding the names of diary entries.

# Should be able to return filenames corresponding to specific timestamps, 
# ranges of entries, single entries and new entries (with a given date). 

import os
from os.path import realpath, join
import math
import datetime
import time
import argparse
import re
from subprocess import check_output

# Load constants that have previously been sourced and exported in bash.
# TODO: change this to use a better way to store and load them. 
dir_entries = os.environ['dir_entries']
device_name = os.environ['device_name']

def new_entry_filename(timestamp=None, device_name=device_name):
    '''Return the full path of a new (not currently existing) entry.
    
    Note that the directory structure may not exist.'''

    # Timestamps can be negative, does this matter?
    timestamp = int(time.time()) if timestamp is None else int(timestamp)
    month = time.strftime('%Y-%m', time.localtime(timestamp))
    filename = 'diary-{}-{}.txt'.format(timestamp, device_name)

    return [realpath(join(dir_entries, month, filename))]

def find_by_timestamp(timestamp):
    '''Returns any entries with the given timestamp.'''
    # Could speed up if the timestamp was used to get the month dir first.
    command = 'find "{}" -iname "*-{}-*"'.format(dir_entries, timestamp)
    results = check_output(command, shell=True, universal_newlines=True)
    return [result for result in results.strip().split('\n') if len(result)>0]

def modified_since(timestamp=0):
    '''Returns all entries last modified after the given timestamp.'''
    command = 'find "{}" -type f -newermt @{}'.format(dir_entries, timestamp)
    all_entries = check_output(command, shell=True, universal_newlines=True)
    return all_entries.split('\n')[:-1]

def walk_all_entries(reverse=False):
    '''Iterates over all entries.'''
    for month in sorted(os.listdir(dir_entries), reverse=reverse):
        for filename in sorted(os.listdir(join(dir_entries, month)), 
                               reverse=reverse):
            yield realpath(join(dir_entries, month, filename))

def range_of_entries(slice_args):
    '''Returns all entries in the given range.'''
    # Note that this is not particularly efficient.
    slice_object = slice(*slice_args)
    all_entries = list(walk_all_entries())
    return all_entries[slice_object]

# TODO
def single_entry(index):
    pass


def range_type(string, range_re=re.compile(
       r'^(?P<start>[+-_]?\d+)?:(?P<stop>[+-_]?\d+)?(?::(?P<step>[+-_]?\d+))?$')):
    match = range_re.match(string)
    if not match: raise argparse.ArgumentTypeError('invalid range')
    
    start, stop, step = match.groups()
    start = None if start is None else int(start.replace('_', '-'))
    stop = None if stop is None else int(stop.replace('_', '-'))
    step = None if step is None else int(step.replace('_', '-'))

    return (start, stop, step)

class QueueAction(argparse.Action):
    '''Appends (dest, arguments) pairs to 'queue' in the returned Namespace.'''
    def __call__(self, parser, namespace, value, option_string=None):
        if not hasattr(namespace, 'queue'): 
            namespace.queue = []
        namespace.queue.append( (self.dest, value) )

parser = argparse.ArgumentParser(description='Get entry filenames.')

# TODO add help and metavar arguments.

parser.add_argument('-n', '--new', nargs='?', type=int, 
                    dest='new_entry_filename', help='', 
                    action=QueueAction, default=argparse.SUPPRESS)

parser.add_argument('-r', '--range', type=range_type,
                    dest='range_of_entries', help='',
                    action=QueueAction, default=argparse.SUPPRESS)
                    
parser.add_argument('-t', '--timestamp', type=int,
                    dest='find_by_timestamp', help='',
                    action=QueueAction, default=argparse.SUPPRESS)

parser.add_argument('-m', '--modified', type=int,
                    dest='modified_since', help='',
                    action=QueueAction, default=argparse.SUPPRESS)

args = parser.parse_args()

filenames = []

# Process tasks in the queue. 
if hasattr(args, 'queue'):
    for func_name, value in args.queue:
        filenames.extend(globals()[func_name](value))

# Print out all filenames in the order specified, separated by newlines.
for filename in filenames:
    print(filename)
